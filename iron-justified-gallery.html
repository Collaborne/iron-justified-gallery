<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../iron-icons/iron-icons.html">

<script type="text/javascript" src="../justified-layout/index.js"></script>

<!--
A gallery for images using flickr justified-layout.

### Example

```html
<iron-justified-gallery images="[[array]]" gallery-width="500" row-height="220">
</iron-justified-gallery>
```

@demo demo/index.html
-->
<dom-module id="iron-justified-gallery">

	<template>

		<style>
			:host {
				position: relative;
				display: block;
			}
		</style>
	</template>
</dom-module>

<script>

(function() {
	const justifiedLayout = require('justified-layout');

	Polymer({
		is: 'iron-justified-gallery',
		properties: {
			/**
			 * Input of images for the galery
			 */
			images: {
				type: Array,
				observer: '_onImagesOrDimensionsChange',
				value: []
			},

			/**
			 * Width of the whole gallery
			 * This value defaults to the width of the element.
			 */
			galleryWidth: Number,

			/**
			 * Height of a single row in the gallery
			 */
			rowHeight: {
				type: Number,
				value: 200
			},
		},

		behaviors: [
			Polymer.IronResizableBehavior
		],

		listeners: {
			'iron-resize': '_onResize',
			'tap': '_onTap'
		},

		// Private methods
		/**
		 * Everytime a width dimension of the gallery space changes,
		 * the gallery needs to be recalculated.
		 * Function is called every-time the window resizes (and once at the page load,
	 	 * more details: https://elements.polymer-project.org/elements/iron-resizable-behavior?active=Polymer.IronResizableBehavior)
		 */
		_onResize: function() {
			this._onImagesOrDimensionsChange(this.images);
		},

		/**
		 * Generates the elements that are going to hold the images with the right positioning and dimensions.
		 * Attaches the elements to the DOM.
		 *
		 * @param images is the array of images that will be rendered
		 * @param	galleryWidth the desired width of the gallery (if not set
		 * 				this defaults to maximal available space for the element)
		 * @param rowHeight the height of a single row. Either set or defaults
		 *				to 200px.
		 */
		_renderImages: function(images, galleryWidth, rowHeight) {
			// set up gallery parameters
			const galleryParameters = {
				containerWidth: galleryWidth || this.offsetWidth,
				targetRowHeight: rowHeight
			};

			// computes relative image sizes
			const normalizedVector = this._computeArrayOfRelativeBoxSizes(images);
			const geometry = this._computePrettyGeometry(normalizedVector, galleryParameters);

			let elementsToBeAttached = '';
			for (let i = 0; i < images.length; i++) {
				const url = images[i].url;
				const box = geometry.boxes[i];
				elementsToBeAttached += `<div index="${i}" ; style="background-size: cover; background-color: black; background-position: center center; background-image: url(${url}); width: ${box.width}px; height: ${box.height}px; top: ${box.top}px; left: ${box.left}px; position: absolute;">`;
				// if there is an icon attached set it in the middle of the image
				if (images[i].icon) {
					elementsToBeAttached += `<iron-icon icon="${images[i].icon}" style="width: 64px; height: 64px; color: white; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);"></iron-icon>`;
				}
				elementsToBeAttached += `</div>`;
			}

			// attach the elements and set the dimensions of the gallery
			this.innerHTML = elementsToBeAttached;
			this.style.height = geometry.containerHeight + "px";
		},
		/**
		 * Computes the box sizes and the size of the whole gallery. In case
		 * that there is only one line and that one is not filled the height of the
		 * gallery will be adjusted to have the row filled. Note that the maximum height
		 * is half of the window height.
		 *
		 * @param normalizedVector Array of relative image sizes
		 * @param galleryParameters Object that characterizes the generated gallery
		 * @return Object that holds characteristics of the gallery. Box sizes, height etc.
		 */
		_computePrettyGeometry: function(normalizedVector, galleryParameters) {
			// compute the geometry for justified gallery (https://github.com/flickr/justified-layout)
			geometry = justifiedLayout(normalizedVector, galleryParameters);

			// save output of function
			const outputOfFirstRowFilled = this._firstRowIsFilled(geometry.boxes, galleryParameters.containerWidth);
			// true if the first row is filled false otherwise
			const firstRowFill = outputOfFirstRowFilled[0];
			// sum of all widths together
			const additiveWidthOfBoxes = outputOfFirstRowFilled[1];
			if (firstRowFill) {
					return geometry;
			} else { // if the first row is not filled
				// compute the height of the row to fill it completely
				const proportionalHeight = galleryParameters.targetRowHeight * (galleryParameters.containerWidth / additiveWidthOfBoxes)
				const maxRowHeight = window.innerHeight/2;
				// use the proportional height if it is smaller than half od the screen
				galleryParameters.targetRowHeight = proportionalHeight > maxRowHeight ? maxRowHeight : proportionalHeight;
				return justifiedLayout(normalizedVector, galleryParameters);
			}
		},
		/**
		 * Checks if all the boxes can fill a single gallery row and computes the
		 * width of all boxes together.
		 *
		 * @param Array of picture box dimensions
		 * @param Number width for the whole gallery
		 * @return Array of length 2, where on 1st possition is a Boolean
		 *				 that shows if the first row is filled or not (true filled
	 	 * 				 false not filled). The 2nd possition holds the width of all
		 *				 boxes together including spaces between them.
		 */
		_firstRowIsFilled: function(boxes, availableWidth) {
			// inicializes the all boxes width to the padding between boxes
			let allBoxesWidth = 10 * (boxes.length - 1);
			// if there is at least a single box compute the sum of widths
			if (boxes.length > 0) {
				allBoxesWidth += boxes.map(box => { return box.width }).reduce((a,b) => { return a + b});
			}
			if (allBoxesWidth > availableWidth) {
				return [true, allBoxesWidth];
			} else {
				return [false, allBoxesWidth];
			}
		},
		/**
		 * Function re-renders images if the input or dimensions has changed
		 *
		 * @param images Array of Objects that hold images that need to be displayed
		 */
		_onImagesOrDimensionsChange: function(images) {
			if (images.length > 1 || !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 750)) {
				this._renderImages(images, this.galleryWidth, this.rowHeight);
			} else if (images.length === 1) {
				this._handleSingleImageCaseForSmallScreens(images[0]);
			}
		},

		/**
		 * Handles a case when there is a single image that needs to take all the space on small screen
		 *
		 * @param image Object that holds and image that needs to be displayed
		 */
		_handleSingleImageCaseForSmallScreens: function(image) {
			const imageHeight = image.height || 450;
			// ensure that there is enough space for the picture
			this.style.height = `${imageHeight}px`;
			let imageDiv = `<div index="0"; style="background-size: cover; background-color: black; background-position: center center; background-image: url(${image.url}); height: ${imageHeight}px; display: block;">`;
			if (image.icon) {
				imageDiv += `<iron-icon icon="${image.icon}" style="width: 64px; height: 64px; color: white; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);"></iron-icon>`;
			}
			imageDiv += `</div>`;
			this.innerHTML = imageDiv;
		},

		/**
		 * Handles the tap on an image.
		 *
		 * @fires 'tap-image' with an image that was tapped as a detail
		 */
		_onTap: function(e) {
			// if the icon was tapped return the parent element
			const box = e.target.nodeName === 'IRON-ICON' ? e.target.parentElement : e.target;
			// find the index of the image that was tapped
			const indexOfTappedImage = box.outerHTML.match(/\d+/);
			this.fire('tap-image', this.images[indexOfTappedImage]);
		},

		/**
		 * Computes the array of box sizes for all attached images. The
		 * vector is build from image ratios (width:height) if both values are provided.
		 * If height is missing the vector is build from widths normalized by
		 * minimum of all width-values. If both widths and heights are missing the
		 * result will be an array of ones.
		 *
		 * For more information about the purpose of this function see:
		 * https://github.com/flickr/justified-layout
		 *
		 * @param images array of all images provided by user
		 * @return array of box sizes computed from images
		 */
		_computeArrayOfRelativeBoxSizes: function(images) {
			// case when all widths and heights are present
			if (this._checkIfImagesHaveParameter(images, 'height') && this._checkIfImagesHaveParameter(images, 'width')) {
				return images.map(image => image.width / image.height)
			// case if all widths are present
			} else if (this._checkIfImagesHaveParameter(images, 'width')) {
				const arrayOfWidths = images.map(image => image.width);
				// compute minimum of all widths
				const minimum = Math.min.apply(Math, arrayOfWidths);
				return arrayOfWidths.map(vetorCell => vetorCell / minimum);
			}
			// case if neither widths nor heights are present
			return new Array(images.length).fill(1);
		},

		/**
		 * Check if all object instances of an array have a certain parameter.
		 *
		 * @param images is the array of objects
		 * @param parameter which existence needs to be verified
		 *				across the whole array.
		 * @return Boolean. True if the parameter is present for all members of the
		 *				 array and false otherwise.For example, if all objects in the
		 *				 array have parameter object.foo, than the function will return true.
		 *				 Note that if the array is empty the return value is false.
		 */
		_checkIfImagesHaveParameter: function(images, parameter) {
			return (images.length > 0) ? images.every(image => Boolean(image[parameter])) : false;
		},
	});

})();

</script>
