<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">

<script type="text/javascript" src="../justified-layout/index.js"></script>

<!--
A gallery for images using flickr justified-layout.

### Example

```html
<iron-justified-gallery images="[[array]]" gallery-width="500" row-height="220">
</iron-justified-gallery>
```

@demo demo/index.html
-->
<dom-module id="iron-justified-gallery">

	<template>

		<style>
			:host {
				position: relative;
				display: block;
			}
		</style>

	</template>
</dom-module>

<script>

(function() {
	const justifiedLayout = require('justified-layout');

	Polymer({
		is: 'iron-justified-gallery',
		properties: {
			/**
			 * Input of images for the galery
			 */
			images: {
				type: Array,
				observer: '_onImageChange',
				value: []
			},

			/**
			 * Width of the whole gallery
			 * This value defaults to the width of the element.
			 */
			galleryWidth: Number,

			/**
			 * Height of a single row in the gallery
			 */
			rowHeight: {
				type: Number,
				value: 200
			}
		},

		behaviors: [
			Polymer.IronResizableBehavior
		],

		listeners: {
			'iron-resize': '_onResize',
			'tap': '_onTap'
		},

		// Private methods
		/**
		 * Everytime a width dimension of the gallery space changes,
		 * the gallery needs to be recalculated.
		 * Function is called every-time the window resizes (and once at the page load,
	 	 * more details: https://elements.polymer-project.org/elements/iron-resizable-behavior?active=Polymer.IronResizableBehavior)
		 */
		_onResize: function() {
			this._renderImages(this.images, this.galleryWidth, this.rowHeight);
		},

		/**
		 * Generates the elements that are going to hold the images with the right positioning and dimensions.
		 * Attaches the elements to the DOM.
		 *
		 * @param images is the array of images that will be rendered
		 * @param	galleryWidth the desired width of the gallery (if not set
		 * 				this defaults to maximal available space for the element)
		 * @param rowHeight the height of a single row. Either set or defaults
		 *				to 200px.
		 */
		_renderImages: function(images, galleryWidth, rowHeight) {
			// set up gallery parameters
			const galleryParameters = {
				containerWidth: galleryWidth || this.offsetWidth,
				targetRowHeight: rowHeight
			};

			// extract image widths
			const arrayOfWidths = images.map(image => image.width);
			const normalizedVector = this._computeNormalizedArrayOfWidths(arrayOfWidths);
			const geometry = justifiedLayout(normalizedVector, galleryParameters);

			let elementsToBeAttached = '';
			for (let i = 0; i < images.length; i++) {
				const url = images[i].url;
				const box = geometry.boxes[i];
				elementsToBeAttached += `<div index="${i}" ; style="background-size: cover; background-position: center center; background-image: url(${url}); width: ${box.width}px; height: ${box.height}px; top: ${box.top}px; left: ${box.left}px; position: absolute;"></div>`;
			}

			// attach the elements and set the dimensions of the gallery
			this.innerHTML = elementsToBeAttached;
			this.style.height = geometry.containerHeight + "px";
		},

		/**
		 * Function re-renders images if the input has changed
		 */
		_onImageChange: function() {
			this._renderImages(this.images, this.galleryWidth, this.rowHeight);
		},

		/**
		 * Handles the tap on an image.
		 *
		 * @fires 'tap-image' with an image that was tapped as a detail
		 */
		_onTap: function(e) {
			// find the index of the image that was tapped
			const indexOfTappedImage = e.target.outerHTML.match(/\d+/);
			this.fire('tap-image', this.images[indexOfTappedImage]);
		},

		/**
		 * Computes the normalized vector of all attached images. The
		 * vector is normalized by minimum value.
		 *
		 * @param arrayOfWidths an array of all images widths
		 * @return array of numbers computed from arrayOfWidths normalized by minimal value
		 */
		_computeNormalizedArrayOfWidths: function(arrayOfWidths) {
			const minimum = Math.min.apply(Math, arrayOfWidths);
			return arrayOfWidths.map(vetorCell => vetorCell / minimum);
		},
	});

})();

</script>
